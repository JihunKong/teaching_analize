"""
Diagnostic Report Generator
Professional medical diagnostic report style for TVAS analysis
Clean, data-rich, immediately comprehensible visualization
"""

from datetime import datetime
from typing import Dict, List, Any, Optional
import json

class DiagnosticReportGenerator:
    """Generate diagnostic professional analysis reports"""

    def __init__(self):
        self.design_system_css = "/static/design_system/index.css"

    def generate_hero_section(self, overall_score: float, percentile: int, profile_type: str) -> str:
        """Generate at-a-glance hero summary section"""

        # Determine status color based on score
        if overall_score >= 80:
            status_class = "score-card--excellent"
            status_text = "ìš°ìˆ˜"
        elif overall_score >= 70:
            status_class = "score-card--good"
            status_text = "ì–‘í˜¸"
        elif overall_score >= 60:
            status_class = "score-card--adequate"
            status_text = "ì ì •"
        else:
            status_class = "score-card--needs-improvement"
            status_text = "ê°œì„ í•„ìš”"

        return f'''
        <div class="hero-summary">
            <div class="hero-summary__title">ì „ì²´ êµìˆ˜ íš¨ê³¼ì„± ì ìˆ˜</div>
            <div class="hero-summary__score">
                {overall_score:.0f}<span class="hero-summary__score-max">/100</span>
            </div>
            <div class="hero-summary__status-bar">
                <div class="hero-summary__status-fill score-card__status-fill--{status_class.split('--')[1]}"
                     style="width: {overall_score}%;"></div>
            </div>
            <div class="hero-summary__percentile">
                ìƒìœ„ {100 - percentile}% ({status_text})
            </div>
            <div class="hero-summary__profile">
                <div class="hero-summary__profile-label">êµìˆ˜ ìœ í˜•</div>
                <div class="hero-summary__profile-type">{profile_type}</div>
            </div>
        </div>
        '''

    def generate_score_card(self, value: float, label: str, max_value: float = 100) -> str:
        """Generate individual metric score card"""

        percentage = (value / max_value) * 100 if max_value > 0 else 0

        # Determine status
        if percentage >= 80:
            status = "excellent"
        elif percentage >= 70:
            status = "good"
        elif percentage >= 60:
            status = "adequate"
        else:
            status = "needs-improvement"

        return f'''
        <div class="score-card score-card--{status}">
            <div class="score-card__label">{label}</div>
            <div class="score-card__value">{value:.1f}</div>
            <div class="score-card__status-bar">
                <div class="score-card__status-fill score-card__status-fill--{status}"
                     style="width: {percentage}%;"></div>
            </div>
        </div>
        '''

    def generate_insight_card(self, title: str, description: str, example: str = None, card_type: str = "strength") -> str:
        """Generate strength or improvement insight card"""

        icon = "âœ“" if card_type == "strength" else "âš "

        example_html = ""
        if example:
            example_html = f'''
            <div class="insight-card__example">
                ë°œí™” ì˜ˆì‹œ: "{example}"
            </div>
            '''

        return f'''
        <div class="insight-card insight-card--{card_type}">
            <div class="insight-card__header">
                <div class="insight-card__icon insight-card__icon--{card_type}">{icon}</div>
                <h4 class="insight-card__title">{title}</h4>
            </div>
            <p class="insight-card__description">{description}</p>
            {example_html}
        </div>
        '''

    def generate_recommendation_card(self, number: int, title: str, description: str, priority: str, why: str = None) -> str:
        """Generate actionable coaching recommendation card"""

        why_html = ""
        if why:
            why_html = f'''
            <div class="recommendation-card__why">
                <div class="recommendation-card__why-title">ì™œ ì¤‘ìš”í•œê°€?</div>
                <p>{why}</p>
            </div>
            '''

        return f'''
        <div class="recommendation-card">
            <div class="recommendation-card__header">
                <div class="recommendation-card__number">{number}</div>
                <h4 class="recommendation-card__title">{title}</h4>
                <span class="recommendation-badge recommendation-badge--{priority}">
                    <span class="recommendation-badge__icon">â—</span>
                    {priority.upper()}
                </span>
            </div>
            <div class="recommendation-card__content">
                <p class="recommendation-card__description">{description}</p>
                {why_html}
            </div>
        </div>
        '''

    def generate_timeline(self, stage_distribution: Dict[str, float]) -> str:
        """Generate lesson progression timeline"""

        intro = stage_distribution.get('introduction', 0)
        dev = stage_distribution.get('development', 0)
        closing = stage_distribution.get('closing', 0)

        return f'''
        <div class="timeline">
            <div class="timeline__segment timeline__segment--introduction" style="width: {intro}%;">
                <span class="timeline__label">ë„ì…</span>
                <span class="timeline__percentage">{intro:.0f}%</span>
            </div>
            <div class="timeline__segment timeline__segment--development" style="width: {dev}%;">
                <span class="timeline__label">ì „ê°œ</span>
                <span class="timeline__percentage">{dev:.0f}%</span>
            </div>
            <div class="timeline__segment timeline__segment--closing" style="width: {closing}%;">
                <span class="timeline__label">ì •ë¦¬</span>
                <span class="timeline__percentage">{closing:.0f}%</span>
            </div>
        </div>
        '''

    def generate_stat_grid(self, stats: List[Dict[str, Any]]) -> str:
        """Generate 3-column stat grid"""

        items_html = ""
        for stat in stats:
            items_html += f'''
            <div class="stat-item">
                <div class="stat-item__label">{stat['label']}</div>
                <div class="stat-item__value">{stat['value']}</div>
            </div>
            '''

        return f'''
        <div class="stat-grid">
            {items_html}
        </div>
        '''

    def _generate_core_metrics_cards(self, quantitative_metrics: Dict[str, Any]) -> str:
        """
        Generate core metrics score cards (top 3 most important metrics)

        Args:
            quantitative_metrics: Dict of metric results

        Returns:
            HTML string with 3 score cards
        """
        if not quantitative_metrics:
            # Fallback to hardcoded values if no metrics available
            return f'''
            {self.generate_score_card(85.0, "ìˆ˜ì—… ë‹¨ê³„ ê· í˜•")}
            {self.generate_score_card(72.0, "ë§¥ë½ ë‹¤ì–‘ì„±")}
            {self.generate_score_card(68.0, "ì¸ì§€ ìˆ˜ì¤€")}
            '''

        # Priority metrics to display (in order of importance)
        priority_metrics = [
            'dev_time_ratio',
            'context_diversity',
            'avg_cognitive_level',
            'question_ratio',
            'higher_order_ratio',
            'cognitive_progression'
        ]

        # Metric name translations (Korean)
        metric_translations = {
            'dev_time_ratio': 'ì „ê°œ ë‹¨ê³„ ê· í˜•',
            'context_diversity': 'ë§¥ë½ ë‹¤ì–‘ì„±',
            'avg_cognitive_level': 'í‰ê·  ì¸ì§€ ìˆ˜ì¤€',
            'question_ratio': 'ì§ˆë¬¸ ë¹„ìœ¨',
            'higher_order_ratio': 'ê³ ì°¨ì›ì  ì‚¬ê³ ',
            'cognitive_progression': 'ì¸ì§€ ìˆ˜ì¤€ ì§„í–‰',
            'intro_time_ratio': 'ë„ì… ë‹¨ê³„ ë¹„ìœ¨',
            'closing_time_ratio': 'ì •ë¦¬ ë‹¨ê³„ ë¹„ìœ¨',
            'feedback_ratio': 'í”¼ë“œë°± ë¹„ìœ¨',
            'explanation_ratio': 'ì„¤ëª… ë¹„ìœ¨'
        }

        # Select top 3 metrics (prioritize priority list, then by score)
        available_metrics = []
        for metric_name in priority_metrics:
            if metric_name in quantitative_metrics:
                metric_data = quantitative_metrics[metric_name]
                available_metrics.append((metric_name, metric_data))

        # If less than 3, add more from remaining metrics
        if len(available_metrics) < 3:
            remaining = [
                (name, data) for name, data in quantitative_metrics.items()
                if name not in [m[0] for m in available_metrics]
            ]
            # Sort by score
            remaining.sort(key=lambda x: x[1].get('normalized_score', 0), reverse=True)
            available_metrics.extend(remaining[:3 - len(available_metrics)])

        # Generate cards
        cards_html = ""
        for metric_name, metric_data in available_metrics[:3]:
            label = metric_translations.get(metric_name, metric_name.replace('_', ' ').title())
            score = metric_data.get('normalized_score', 0)
            cards_html += self.generate_score_card(score, label)

        return cards_html

    # ============ Chart Generation Methods ============

    def _generate_chartjs_config(
        self,
        chart_type: str,
        labels: List[str],
        datasets: List[Dict[str, Any]],
        options: Dict[str, Any] = None
    ) -> str:
        """
        Generate Chart.js configuration JSON

        Args:
            chart_type: 'radar', 'bar', 'line', 'doughnut', 'pie'
            labels: Chart labels
            datasets: List of dataset configurations
            options: Chart.js options

        Returns:
            JSON string configuration
        """
        import json

        default_options = {
            'responsive': True,
            'maintainAspectRatio': False,
            'plugins': {
                'legend': {
                    'display': True,
                    'position': 'top'
                }
            }
        }

        if options:
            default_options.update(options)

        config = {
            'type': chart_type,
            'data': {
                'labels': labels,
                'datasets': datasets
            },
            'options': default_options
        }

        return json.dumps(config, ensure_ascii=False)

    def generate_metrics_radar_chart(self, quantitative_metrics: Dict[str, Any]) -> str:
        """
        Generate radar chart for top 7-8 metrics

        Returns:
            HTML with canvas and Chart.js config
        """
        import json

        # Priority metrics for radar chart
        priority_metrics = [
            'dev_time_ratio',
            'context_diversity',
            'avg_cognitive_level',
            'question_ratio',
            'feedback_ratio',
            'higher_order_ratio',
            'cognitive_progression'
        ]

        metric_labels = {
            'dev_time_ratio': 'ì „ê°œ ë‹¨ê³„',
            'context_diversity': 'ë§¥ë½ ë‹¤ì–‘ì„±',
            'avg_cognitive_level': 'ì¸ì§€ ìˆ˜ì¤€',
            'question_ratio': 'ì§ˆë¬¸ ë¹„ìœ¨',
            'feedback_ratio': 'í”¼ë“œë°±',
            'higher_order_ratio': 'ê³ ì°¨ì› ì‚¬ê³ ',
            'cognitive_progression': 'ì¸ì§€ ì§„í–‰'
        }

        # Extract scores
        labels = []
        scores = []
        for metric in priority_metrics:
            if metric in quantitative_metrics:
                labels.append(metric_labels.get(metric, metric))
                scores.append(quantitative_metrics[metric].get('normalized_score', 0))

        # Create dataset
        dataset = {
            'label': 'í˜„ì¬ ì ìˆ˜',
            'data': scores,
            'backgroundColor': 'rgba(102, 126, 234, 0.2)',
            'borderColor': 'rgb(102, 126, 234)',
            'borderWidth': 2,
            'pointBackgroundColor': 'rgb(102, 126, 234)',
            'pointBorderColor': '#fff',
            'pointHoverBackgroundColor': '#fff',
            'pointHoverBorderColor': 'rgb(102, 126, 234)'
        }

        config = self._generate_chartjs_config(
            'radar',
            labels,
            [dataset],
            {
                'scales': {
                    'r': {
                        'beginAtZero': True,
                        'max': 100,
                        'ticks': {
                            'stepSize': 20
                        }
                    }
                }
            }
        )

        return f'''
        <div class="chart-container" style="height: 280px;">
            <canvas id="metricsRadarChart"></canvas>
        </div>
        <script>
            (function() {{
                const ctx = document.getElementById('metricsRadarChart').getContext('2d');
                new Chart(ctx, {config});
            }})();
        </script>
        '''

    def generate_detailed_metrics_bar_chart(self, quantitative_metrics: Dict[str, Any]) -> str:
        """
        Generate horizontal bar chart for all 15 metrics

        Returns:
            HTML with canvas and Chart.js config
        """
        import json

        # Get all metrics sorted by score
        metrics_list = []
        for name, data in quantitative_metrics.items():
            metrics_list.append({
                'name': name,
                'score': data.get('normalized_score', 0),
                'status': data.get('status', 'good')
            })

        metrics_list.sort(key=lambda x: x['score'], reverse=True)

        # Metric translations
        metric_translations = {
            'dev_time_ratio': 'ì „ê°œ ë‹¨ê³„ ë¹„ìœ¨',
            'context_diversity': 'ë§¥ë½ ë‹¤ì–‘ì„±',
            'avg_cognitive_level': 'í‰ê·  ì¸ì§€ ìˆ˜ì¤€',
            'question_ratio': 'ì§ˆë¬¸ ë¹„ìœ¨',
            'higher_order_ratio': 'ê³ ì°¨ì› ì‚¬ê³  ë¹„ìœ¨',
            'cognitive_progression': 'ì¸ì§€ ìˆ˜ì¤€ ì§„í–‰',
            'intro_time_ratio': 'ë„ì… ë‹¨ê³„ ë¹„ìœ¨',
            'closing_time_ratio': 'ì •ë¦¬ ë‹¨ê³„ ë¹„ìœ¨',
            'feedback_ratio': 'í”¼ë“œë°± ë¹„ìœ¨',
            'explanation_ratio': 'ì„¤ëª… ë¹„ìœ¨',
            'utterance_density': 'ë°œí™” ë°€ë„',
            'extended_dialogue_ratio': 'í™•ì¥ ëŒ€í™” ë¹„ìœ¨',
            'avg_wait_time': 'í‰ê·  ëŒ€ê¸° ì‹œê°„',
            'irf_pattern_ratio': 'IRF íŒ¨í„´ ë¹„ìœ¨',
            'dev_question_depth': 'ì „ê°œ ì§ˆë¬¸ ê¹Šì´'
        }

        labels = [metric_translations.get(m['name'], m['name']) for m in metrics_list]
        scores = [m['score'] for m in metrics_list]

        # Color-code by status
        colors = []
        for m in metrics_list:
            if m['score'] >= 80:
                colors.append('rgba(16, 185, 129, 0.8)')  # success
            elif m['score'] >= 70:
                colors.append('rgba(59, 130, 246, 0.8)')  # info
            elif m['score'] >= 60:
                colors.append('rgba(245, 158, 11, 0.8)')  # warning
            else:
                colors.append('rgba(239, 68, 68, 0.8)')   # danger

        dataset = {
            'label': 'ì ìˆ˜',
            'data': scores,
            'backgroundColor': colors,
            'borderColor': colors,
            'borderWidth': 1
        }

        config = self._generate_chartjs_config(
            'bar',
            labels,
            [dataset],
            {
                'indexAxis': 'y',
                'scales': {
                    'x': {
                        'beginAtZero': True,
                        'max': 100
                    }
                },
                'plugins': {
                    'legend': {
                        'display': False
                    }
                }
            }
        )

        return f'''
        <div class="chart-container" style="height: 400px;">
            <canvas id="detailedMetricsBarChart"></canvas>
        </div>
        <script>
            (function() {{
                const ctx = document.getElementById('detailedMetricsBarChart').getContext('2d');
                new Chart(ctx, {config});
            }})();
        </script>
        '''

    def generate_stage_distribution_chart(self, matrix_analysis: Dict[str, Any]) -> str:
        """
        Generate pie/doughnut chart for stage distribution

        Returns:
            HTML with canvas and Chart.js config
        """
        import json

        # Extract stage distribution
        stats = matrix_analysis.get('statistics', {})
        stage_stats = stats.get('stage_stats', {})
        stage_dist = stage_stats.get('stage_distribution', {})

        labels = ['ë„ì…', 'ì „ê°œ', 'ì •ë¦¬']
        data = [
            stage_dist.get('introduction', 0),
            stage_dist.get('development', 0),
            stage_dist.get('closing', 0)
        ]

        dataset = {
            'data': data,
            'backgroundColor': [
                'rgba(102, 126, 234, 0.8)',  # primary
                'rgba(118, 75, 162, 0.8)',   # secondary
                'rgba(59, 130, 246, 0.8)'    # info
            ],
            'borderColor': '#fff',
            'borderWidth': 2
        }

        config = self._generate_chartjs_config(
            'doughnut',
            labels,
            [dataset],
            {
                'plugins': {
                    'legend': {
                        'position': 'bottom'
                    }
                }
            }
        )

        return f'''
        <div class="chart-container" style="height: 220px;">
            <canvas id="stageDistChart"></canvas>
        </div>
        <script>
            (function() {{
                const ctx = document.getElementById('stageDistChart').getContext('2d');
                new Chart(ctx, {config});
            }})();
        </script>
        '''

    def generate_context_distribution_chart(self, matrix_analysis: Dict[str, Any]) -> str:
        """
        Generate bar chart for context distribution

        Returns:
            HTML with canvas and Chart.js config
        """
        import json

        # Extract context distribution
        stats = matrix_analysis.get('statistics', {})
        context_stats = stats.get('context_stats', {})
        context_dist = context_stats.get('context_distribution', {})

        labels = ['ì„¤ëª…', 'ì§ˆë¬¸', 'í”¼ë“œë°±', 'ì´‰ì§„', 'ê´€ë¦¬']
        data = [
            context_dist.get('explanation', 0),
            context_dist.get('question', 0),
            context_dist.get('feedback', 0),
            context_dist.get('facilitation', 0),
            context_dist.get('management', 0)
        ]

        dataset = {
            'label': 'ë¹„ìœ¨ (%)',
            'data': data,
            'backgroundColor': 'rgba(102, 126, 234, 0.8)',
            'borderColor': 'rgb(102, 126, 234)',
            'borderWidth': 1
        }

        config = self._generate_chartjs_config(
            'bar',
            labels,
            [dataset],
            {
                'scales': {
                    'y': {
                        'beginAtZero': True,
                        'max': 100
                    }
                },
                'plugins': {
                    'legend': {
                        'display': False
                    }
                }
            }
        )

        return f'''
        <div class="chart-container" style="height: 220px;">
            <canvas id="contextDistChart"></canvas>
        </div>
        <script>
            (function() {{
                const ctx = document.getElementById('contextDistChart').getContext('2d');
                new Chart(ctx, {config});
            }})();
        </script>
        '''

    def generate_level_distribution_chart(self, matrix_analysis: Dict[str, Any]) -> str:
        """
        Generate stacked bar chart for cognitive level distribution

        Returns:
            HTML with canvas and Chart.js config
        """
        import json

        # Extract level distribution
        stats = matrix_analysis.get('statistics', {})
        level_stats = stats.get('level_stats', {})
        level_dist = level_stats.get('level_distribution', {})

        labels = ['ì¸ì§€ ìˆ˜ì¤€ ë¶„í¬']
        l1_data = [level_dist.get('L1', 0)]
        l2_data = [level_dist.get('L2', 0)]
        l3_data = [level_dist.get('L3', 0)]

        datasets = [
            {
                'label': 'L1 (ê¸°ì–µ/ì´í•´)',
                'data': l1_data,
                'backgroundColor': 'rgba(59, 130, 246, 0.8)'
            },
            {
                'label': 'L2 (ì ìš©/ë¶„ì„)',
                'data': l2_data,
                'backgroundColor': 'rgba(16, 185, 129, 0.8)'
            },
            {
                'label': 'L3 (í‰ê°€/ì°½ì¡°)',
                'data': l3_data,
                'backgroundColor': 'rgba(245, 158, 11, 0.8)'
            }
        ]

        config = self._generate_chartjs_config(
            'bar',
            labels,
            datasets,
            {
                'indexAxis': 'y',
                'scales': {
                    'x': {
                        'stacked': True,
                        'max': 100
                    },
                    'y': {
                        'stacked': True
                    }
                }
            }
        )

        return f'''
        <div class="chart-container" style="height: 120px;">
            <canvas id="levelDistChart"></canvas>
        </div>
        <script>
            (function() {{
                const ctx = document.getElementById('levelDistChart').getContext('2d');
                new Chart(ctx, {config});
            }})();
        </script>
        '''

    def generate_pattern_similarity_chart(self, pattern_matching: Dict[str, Any]) -> str:
        """
        Generate bar chart for pattern similarity scores

        Returns:
            HTML with canvas and Chart.js config
        """
        import json

        # Get all pattern similarities
        all_patterns = pattern_matching.get('all_pattern_similarities', [])

        # Handle both dict and list formats
        if isinstance(all_patterns, dict):
            # Convert dict to list of dicts and sort by similarity
            pattern_list = [
                {'pattern_name': name, 'similarity': score}
                for name, score in all_patterns.items()
            ]
            sorted_patterns = sorted(pattern_list, key=lambda x: x['similarity'], reverse=True)[:5]
            labels = [p['pattern_name'] for p in sorted_patterns]
            data = [p['similarity'] * 100 for p in sorted_patterns]
        elif not all_patterns:
            # Fallback to best match only
            best_match = pattern_matching.get('best_match', {})
            labels = [best_match.get('pattern_name', 'ê· í˜•ì¡íŒ ì´‰ì§„ì')]
            data = [best_match.get('similarity_score', 0.75) * 100]
        else:
            # Original list format
            sorted_patterns = sorted(all_patterns, key=lambda x: x['similarity'], reverse=True)[:5]
            labels = [p['pattern_name'] for p in sorted_patterns]
            data = [p['similarity'] * 100 for p in sorted_patterns]

        # Color first bar differently (best match)
        colors = ['rgba(102, 126, 234, 0.8)']  # primary for best match
        colors.extend(['rgba(156, 163, 175, 0.6)'] * (len(data) - 1))  # gray for others

        dataset = {
            'label': 'ìœ ì‚¬ë„ (%)',
            'data': data,
            'backgroundColor': colors,
            'borderColor': colors,
            'borderWidth': 1
        }

        config = self._generate_chartjs_config(
            'bar',
            labels,
            [dataset],
            {
                'scales': {
                    'y': {
                        'beginAtZero': True,
                        'max': 100
                    }
                },
                'plugins': {
                    'legend': {
                        'display': False
                    }
                }
            }
        )

        return f'''
        <div class="chart-container" style="height: 220px;">
            <canvas id="patternSimilarityChart"></canvas>
        </div>
        <script>
            (function() {{
                const ctx = document.getElementById('patternSimilarityChart').getContext('2d');
                new Chart(ctx, {config});
            }})();
        </script>
        '''

    # ============ End Chart Generation Methods ============

    # ============ Data Extraction Helper Methods ============

    def _extract_stage_distribution(self, matrix_analysis: Dict[str, Any]) -> Dict[str, float]:
        """
        Extract stage distribution percentages from matrix analysis

        Args:
            matrix_analysis: Matrix analysis result containing statistics

        Returns:
            Dict with stage percentages: {"introduction": 15.5, "development": 68.2, "closing": 16.3}
        """
        stats = matrix_analysis.get('statistics', {})
        stage_stats = stats.get('stage_stats', {})
        stage_dist = stage_stats.get('stage_distribution', {})

        # Return with default 0 values if not present
        return {
            'introduction': stage_dist.get('introduction', 0.0),
            'development': stage_dist.get('development', 0.0),
            'closing': stage_dist.get('closing', 0.0)
        }

    def _extract_context_distribution(self, matrix_analysis: Dict[str, Any]) -> Dict[str, float]:
        """
        Extract context distribution percentages from matrix analysis

        Args:
            matrix_analysis: Matrix analysis result containing statistics

        Returns:
            Dict with context percentages: {"explanation": 35, "question": 25, ...}
        """
        stats = matrix_analysis.get('statistics', {})
        context_stats = stats.get('context_stats', {})
        context_dist = context_stats.get('context_distribution', {})

        return {
            'explanation': context_dist.get('explanation', 0.0),
            'question': context_dist.get('question', 0.0),
            'feedback': context_dist.get('feedback', 0.0),
            'facilitation': context_dist.get('facilitation', 0.0),
            'management': context_dist.get('management', 0.0)
        }

    def _extract_level_distribution(self, matrix_analysis: Dict[str, Any]) -> Dict[str, float]:
        """
        Extract cognitive level distribution percentages from matrix analysis

        Args:
            matrix_analysis: Matrix analysis result containing statistics

        Returns:
            Dict with level percentages: {"L1": 40, "L2": 35, "L3": 25}
        """
        stats = matrix_analysis.get('statistics', {})
        level_stats = stats.get('level_stats', {})
        level_dist = level_stats.get('level_distribution', {})

        return {
            'L1': level_dist.get('L1', 0.0),
            'L2': level_dist.get('L2', 0.0),
            'L3': level_dist.get('L3', 0.0)
        }

    def _extract_top_metrics(
        self,
        quantitative_metrics: Dict[str, Any],
        count: int = 7
    ) -> List[Dict[str, Any]]:
        """
        Get top N metrics by priority/importance

        Priority order:
        1. dev_time_ratio (ì „ê°œ ë‹¨ê³„ ê· í˜•)
        2. context_diversity (ë§¥ë½ ë‹¤ì–‘ì„±)
        3. avg_cognitive_level (í‰ê·  ì¸ì§€ ìˆ˜ì¤€)
        4. question_ratio (ì§ˆë¬¸ ë¹„ìœ¨)
        5. feedback_ratio (í”¼ë“œë°± ë¹„ìœ¨)
        6. higher_order_ratio (ê³ ì°¨ì› ì‚¬ê³  ë¹„ìœ¨)
        7. cognitive_progression (ì¸ì§€ ìˆ˜ì¤€ ì§„í–‰)

        Args:
            quantitative_metrics: Dict of metric results
            count: Number of top metrics to return (default: 7)

        Returns:
            List of metric dicts with name, score, status, korean_name
        """
        priority_order = [
            'dev_time_ratio',
            'context_diversity',
            'avg_cognitive_level',
            'question_ratio',
            'feedback_ratio',
            'higher_order_ratio',
            'cognitive_progression',
            'intro_time_ratio',
            'closing_time_ratio',
            'explanation_ratio',
            'utterance_density',
            'extended_dialogue_ratio',
            'avg_wait_time',
            'irf_pattern_ratio',
            'dev_question_depth'
        ]

        metric_translations = {
            'dev_time_ratio': 'ì „ê°œ ë‹¨ê³„ ë¹„ìœ¨',
            'context_diversity': 'ë§¥ë½ ë‹¤ì–‘ì„±',
            'avg_cognitive_level': 'í‰ê·  ì¸ì§€ ìˆ˜ì¤€',
            'question_ratio': 'ì§ˆë¬¸ ë¹„ìœ¨',
            'feedback_ratio': 'í”¼ë“œë°± ë¹„ìœ¨',
            'higher_order_ratio': 'ê³ ì°¨ì› ì‚¬ê³  ë¹„ìœ¨',
            'cognitive_progression': 'ì¸ì§€ ìˆ˜ì¤€ ì§„í–‰',
            'intro_time_ratio': 'ë„ì… ë‹¨ê³„ ë¹„ìœ¨',
            'closing_time_ratio': 'ì •ë¦¬ ë‹¨ê³„ ë¹„ìœ¨',
            'explanation_ratio': 'ì„¤ëª… ë¹„ìœ¨',
            'utterance_density': 'ë°œí™” ë°€ë„',
            'extended_dialogue_ratio': 'í™•ì¥ ëŒ€í™” ë¹„ìœ¨',
            'avg_wait_time': 'í‰ê·  ëŒ€ê¸° ì‹œê°„',
            'irf_pattern_ratio': 'IRF íŒ¨í„´ ë¹„ìœ¨',
            'dev_question_depth': 'ì „ê°œ ì§ˆë¬¸ ê¹Šì´'
        }

        top_metrics = []
        for metric_name in priority_order[:count]:
            if metric_name in quantitative_metrics:
                metric_data = quantitative_metrics[metric_name]
                top_metrics.append({
                    'name': metric_name,
                    'korean_name': metric_translations.get(metric_name, metric_name),
                    'score': metric_data.get('normalized_score', 0),
                    'value': metric_data.get('value', 0),
                    'status': metric_data.get('status', 'good')
                })

        return top_metrics

    def _extract_all_metrics_sorted(
        self,
        quantitative_metrics: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Get all 15 metrics sorted by category and score

        Categories:
        - Time Dimension: intro_time_ratio, dev_time_ratio, closing_time_ratio
        - Context Dimension: context_diversity, explanation_ratio, question_ratio, feedback_ratio
        - Cognitive Dimension: avg_cognitive_level, higher_order_ratio, cognitive_progression
        - Interaction Quality: utterance_density, extended_dialogue_ratio, avg_wait_time
        - Composite Patterns: irf_pattern_ratio, dev_question_depth

        Args:
            quantitative_metrics: Dict of metric results

        Returns:
            List of metric dicts sorted by score (descending)
        """
        metric_translations = {
            'dev_time_ratio': 'ì „ê°œ ë‹¨ê³„ ë¹„ìœ¨',
            'context_diversity': 'ë§¥ë½ ë‹¤ì–‘ì„±',
            'avg_cognitive_level': 'í‰ê·  ì¸ì§€ ìˆ˜ì¤€',
            'question_ratio': 'ì§ˆë¬¸ ë¹„ìœ¨',
            'higher_order_ratio': 'ê³ ì°¨ì› ì‚¬ê³  ë¹„ìœ¨',
            'cognitive_progression': 'ì¸ì§€ ìˆ˜ì¤€ ì§„í–‰',
            'intro_time_ratio': 'ë„ì… ë‹¨ê³„ ë¹„ìœ¨',
            'closing_time_ratio': 'ì •ë¦¬ ë‹¨ê³„ ë¹„ìœ¨',
            'feedback_ratio': 'í”¼ë“œë°± ë¹„ìœ¨',
            'explanation_ratio': 'ì„¤ëª… ë¹„ìœ¨',
            'utterance_density': 'ë°œí™” ë°€ë„',
            'extended_dialogue_ratio': 'í™•ì¥ ëŒ€í™” ë¹„ìœ¨',
            'avg_wait_time': 'í‰ê·  ëŒ€ê¸° ì‹œê°„',
            'irf_pattern_ratio': 'IRF íŒ¨í„´ ë¹„ìœ¨',
            'dev_question_depth': 'ì „ê°œ ì§ˆë¬¸ ê¹Šì´'
        }

        metric_categories = {
            'intro_time_ratio': 'time',
            'dev_time_ratio': 'time',
            'closing_time_ratio': 'time',
            'context_diversity': 'context',
            'explanation_ratio': 'context',
            'question_ratio': 'context',
            'feedback_ratio': 'context',
            'avg_cognitive_level': 'cognitive',
            'higher_order_ratio': 'cognitive',
            'cognitive_progression': 'cognitive',
            'utterance_density': 'interaction',
            'extended_dialogue_ratio': 'interaction',
            'avg_wait_time': 'interaction',
            'irf_pattern_ratio': 'composite',
            'dev_question_depth': 'composite'
        }

        all_metrics = []
        for metric_name, metric_data in quantitative_metrics.items():
            all_metrics.append({
                'name': metric_name,
                'korean_name': metric_translations.get(metric_name, metric_name),
                'category': metric_categories.get(metric_name, 'other'),
                'score': metric_data.get('normalized_score', 0),
                'value': metric_data.get('value', 0),
                'status': metric_data.get('status', 'good')
            })

        # Sort by score descending
        all_metrics.sort(key=lambda x: x['score'], reverse=True)

        return all_metrics

    # ============ End Data Extraction Methods ============

    def calculate_overall_score(self, quantitative_metrics: Dict[str, Any]) -> float:
        """
        Calculate overall score from quantitative metrics

        Args:
            quantitative_metrics: Dict of metric results

        Returns:
            Overall score (0-100 average)
        """
        if not quantitative_metrics:
            return 75.0

        scores = []
        for metric_name, metric_data in quantitative_metrics.items():
            score = metric_data.get('normalized_score', 0)
            scores.append(score)

        if not scores:
            return 75.0

        return sum(scores) / len(scores)

    def calculate_percentile(self, overall_score: float) -> int:
        """
        Estimate percentile ranking based on overall score

        Args:
            overall_score: Overall score (0-100)

        Returns:
            Estimated percentile (0-100)
        """
        # Simplified percentile estimation
        # In production, this would compare against database of scores
        if overall_score >= 90:
            return 95  # Top 5%
        elif overall_score >= 80:
            return 75  # Top 25%
        elif overall_score >= 70:
            return 50  # Top 50%
        elif overall_score >= 60:
            return 30  # Top 70%
        else:
            return 10  # Bottom 90%

    def generate_html_report(self, analysis_data: Dict[str, Any]) -> str:
        """
        Generate complete diagnostic HTML report

        Args:
            analysis_data: Full analysis result with coaching, metrics, patterns

        Returns:
            Complete HTML document string
        """

        framework = analysis_data.get('framework', 'cbil_comprehensive')
        timestamp = datetime.now().strftime('%Yë…„ %mì›” %dì¼ %H:%M')
        analysis_id = analysis_data.get('analysis_id', 'N/A')

        # Extract key data
        coaching_feedback = analysis_data.get('coaching_feedback', {})
        quantitative_metrics = analysis_data.get('quantitative_metrics', {})
        pattern_matching = analysis_data.get('pattern_matching', {})
        matrix_analysis = analysis_data.get('matrix_analysis', {})

        # Calculate overall score from actual metrics
        overall_score = self.calculate_overall_score(quantitative_metrics)
        percentile = self.calculate_percentile(overall_score)
        profile_type = pattern_matching.get('best_match', {}).get('pattern_name', 'ê· í˜•ì¡íŒ ì´‰ì§„ì')

        # Generate hero section
        hero_html = self.generate_hero_section(overall_score, percentile, profile_type)

        # Generate core metric score cards (use top 3 metrics by score)
        core_metrics_html = self._generate_core_metrics_cards(quantitative_metrics)

        # Generate strengths and improvements
        strengths_html = ""
        for i, strength in enumerate(coaching_feedback.get('strengths', [])[:3]):
            strengths_html += self.generate_insight_card(
                title=f"ê°•ì  {i+1}",
                description=strength,
                card_type="strength"
            )

        improvements_html = ""
        areas_for_growth = coaching_feedback.get('areas_for_growth', [])
        if not areas_for_growth:
            areas_for_growth = coaching_feedback.get('areas_for_improvement', [])
        for i, improvement in enumerate(areas_for_growth[:3]):
            improvements_html += self.generate_insight_card(
                title=f"ê°œì„  ì˜ì—­ {i+1}",
                description=improvement,
                card_type="improvement"
            )

        # Generate recommendations
        recommendations_html = ""
        for i, action in enumerate(coaching_feedback.get('priority_actions', [])[:5], 1):
            priority = "high" if i <= 2 else "medium" if i <= 4 else "low"
            recommendations_html += self.generate_recommendation_card(
                number=i,
                title=action,
                description="",  # Removed redundant text
                priority=priority
            )

        # Generate charts for new sections
        metrics_radar_chart = self.generate_metrics_radar_chart(quantitative_metrics)
        detailed_metrics_bar_chart = self.generate_detailed_metrics_bar_chart(quantitative_metrics)

        stage_distribution_chart = self.generate_stage_distribution_chart(matrix_analysis)
        context_distribution_chart = self.generate_context_distribution_chart(matrix_analysis)
        level_distribution_chart = self.generate_level_distribution_chart(matrix_analysis)

        pattern_similarity_chart = self.generate_pattern_similarity_chart(pattern_matching)

        # Extract distribution data for text display
        stage_dist = self._extract_stage_distribution(matrix_analysis)
        context_dist = self._extract_context_distribution(matrix_analysis)
        level_dist = self._extract_level_distribution(matrix_analysis)

        # Extract individual values for template
        stage_intro = stage_dist.get('introduction', 0)
        stage_dev = stage_dist.get('development', 0)
        stage_close = stage_dist.get('closing', 0)

        context_expl = context_dist.get('explanation', 0)
        context_ques = context_dist.get('question', 0)
        context_feed = context_dist.get('feedback', 0)

        level_l1 = level_dist.get('L1', 0)
        level_l2 = level_dist.get('L2', 0)
        level_l3 = level_dist.get('L3', 0)

        # Extract pattern matching info
        best_match = pattern_matching.get('best_match', {})
        best_pattern_name = best_match.get('pattern_name', 'ê· í˜•ì¡íŒ ì´‰ì§„ì')
        best_pattern_description = best_match.get('pattern_description', 'ì „ê°œ ë‹¨ê³„ ì¤‘ì‹¬, ë‹¤ì–‘í•œ ë§¥ë½ í™œìš©')
        best_pattern_similarity = best_match.get('similarity_score', 0.75) * 100

        # Build complete HTML
        html = f'''
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TVAS êµìˆ˜ ë¶„ì„ ë³´ê³ ì„œ</title>
    <link rel="stylesheet" href="{self.design_system_css}">
    <style>
        /* Additional page-specific styles */
        .report-header {{
            background: var(--white);
            border-bottom: var(--border-thick) solid var(--primary-700);
            padding: var(--space-3-compact);
            margin-bottom: var(--space-4-compact);
        }}

        .report-header__title {{
            font-size: 1.375rem;
            font-weight: var(--weight-bold);
            color: var(--primary-900);
            margin-bottom: var(--space-1);
        }}

        .report-header__meta {{
            font-size: var(--text-sm);
            color: var(--gray-600);
        }}

        /* Compact spacing overrides */
        :root {{
            --space-3-compact: 1rem;      /* 24px â†’ 16px */
            --space-4-compact: 1.5rem;    /* 32px â†’ 24px */
            --space-6-compact: 2rem;      /* 48px â†’ 32px */
        }}

        /* Two-column master layout */
        .two-column-layout {{
            display: grid;
            grid-template-columns: 60% 38%;
            gap: 2%;
            margin-top: var(--space-4-compact);
            align-items: start;
        }}

        .two-column-layout__left {{
            /* Main content area - charts and analysis */
        }}

        .two-column-layout__right {{
            /* Sidebar - profile, strengths, improvements, recommendations */
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }}

        .sidebar-section {{
            margin-bottom: var(--space-3-compact);
        }}

        .sidebar-card {{
            background: var(--white);
            border-radius: var(--radius-lg);
            padding: var(--space-3-compact);
            box-shadow: var(--shadow-md);
            margin-bottom: 12px;
        }}

        /* Chart Container Centering */
        .chart-container {{
            position: relative;
            margin: 20px auto;
            max-width: 700px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
        }}

        /* Section and card spacing */
        .section {{
            margin-bottom: var(--space-4-compact);
        }}

        .section-header {{
            margin-bottom: var(--space-3-compact);
        }}

        .section-title {{
            font-size: 1.125rem;  /* 20px â†’ 18px */
        }}

        @media (max-width: 1200px) {{
            .two-column-layout {{
                grid-template-columns: 1fr;
                gap: var(--space-4);
            }}

            .two-column-layout__right {{
                position: static;
                max-height: none;
            }}
        }}

        @media (max-width: 768px) {{
            .chart-container {{
                max-width: 100%;
                margin: 20px auto;
                padding: 15px;
            }}
        }}
    </style>

    <!-- Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="report-header">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="report-header__title">TVAS êµìˆ˜ ë¶„ì„ ë³´ê³ ì„œ</h1>
                    <div class="report-header__meta">
                        ë¶„ì„ ID: {analysis_id} | ìƒì„±ì¼: {timestamp}
                    </div>
                </div>
                <div class="text-right">
                    <div class="text-sm text-muted">êµì‚¬ ë°œí™” ë¶„ì„ ì‹œìŠ¤í…œ</div>
                    <div class="text-xs text-muted">ì „ë¬¸ ì§„ë‹¨ ë³´ê³ ì„œ</div>
                </div>
            </div>
        </header>

        <!-- Hero Summary -->
        {hero_html}

        <!-- Two-Column Layout -->
        <div class="two-column-layout">
            <!-- Left Column: Charts and Analysis -->
            <div class="two-column-layout__left">

        <!-- Core Metrics (3-column) -->
        <section class="section">
            <div class="section-header">
                <h2 class="section-title">í•µì‹¬ ì§€í‘œ</h2>
            </div>
            <div class="grid grid-cols-3 gap-4">
                {core_metrics_html}
            </div>
        </section>

        <!-- Detailed Metrics Analysis -->
        <section class="section">
            <div class="section-header">
                <h2 class="section-title">ìƒì„¸ ì§€í‘œ ë¶„ì„</h2>
                <p class="section-subtitle">ì „ì²´ 15ê°œ ì§€í‘œì˜ ì¢…í•© í‰ê°€</p>
            </div>
            <div class="grid grid-cols-2 gap-6 mb-6">
                <div>
                    <div class="subsection-header">
                        <span class="subsection-header__icon">ğŸ“Š</span>
                        <h3 class="subsection-header__title">ì£¼ìš” ì§€í‘œ ë ˆì´ë” ì°¨íŠ¸</h3>
                    </div>
                    {metrics_radar_chart}
                </div>
                <div>
                    <div class="subsection-header">
                        <span class="subsection-header__icon">ğŸ“ˆ</span>
                        <h3 class="subsection-header__title">ì „ì²´ ì§€í‘œ ì ìˆ˜</h3>
                    </div>
                    {detailed_metrics_bar_chart}
                </div>
            </div>
        </section>

        <!-- Distribution Analysis -->
        <section class="section">
            <div class="section-header">
                <h2 class="section-title">ìˆ˜ì—… êµ¬ì¡° ë¶„ì„</h2>
                <p class="section-subtitle">ìˆ˜ì—… ë‹¨ê³„, êµìˆ˜ ê¸°ëŠ¥, ì¸ì§€ ìˆ˜ì¤€ ë¶„í¬</p>
            </div>
            <div class="grid grid-cols-3 gap-6">
                <div>
                    <div class="subsection-header">
                        <span class="subsection-header__icon">â±ï¸</span>
                        <h3 class="subsection-header__title">ìˆ˜ì—… ë‹¨ê³„ ë¶„í¬</h3>
                    </div>
                    {stage_distribution_chart}
                    <div class="metric-stats-grid mt-3">
                        <div class="metric-stat-pill metric-stat-pill--primary">
                            <span class="metric-stat-pill__label">ë„ì…</span>
                            <span class="metric-stat-pill__value">{stage_intro:.1f}%</span>
                            <div class="metric-stat-pill__bar" style="width: {stage_intro}%;"></div>
                        </div>
                        <div class="metric-stat-pill metric-stat-pill--secondary">
                            <span class="metric-stat-pill__label">ì „ê°œ</span>
                            <span class="metric-stat-pill__value">{stage_dev:.1f}%</span>
                            <div class="metric-stat-pill__bar" style="width: {stage_dev}%;"></div>
                        </div>
                        <div class="metric-stat-pill metric-stat-pill--info">
                            <span class="metric-stat-pill__label">ì •ë¦¬</span>
                            <span class="metric-stat-pill__value">{stage_close:.1f}%</span>
                            <div class="metric-stat-pill__bar" style="width: {stage_close}%;"></div>
                        </div>
                    </div>
                </div>
                <div>
                    <div class="subsection-header">
                        <span class="subsection-header__icon">ğŸ¯</span>
                        <h3 class="subsection-header__title">êµìˆ˜ ê¸°ëŠ¥ ë¶„í¬</h3>
                    </div>
                    {context_distribution_chart}
                    <div class="metric-stats-grid mt-3">
                        <div class="metric-stat-pill metric-stat-pill--primary">
                            <span class="metric-stat-pill__label">ì„¤ëª…</span>
                            <span class="metric-stat-pill__value">{context_expl:.1f}%</span>
                            <div class="metric-stat-pill__bar" style="width: {context_expl}%;"></div>
                        </div>
                        <div class="metric-stat-pill metric-stat-pill--success">
                            <span class="metric-stat-pill__label">ì§ˆë¬¸</span>
                            <span class="metric-stat-pill__value">{context_ques:.1f}%</span>
                            <div class="metric-stat-pill__bar" style="width: {context_ques}%;"></div>
                        </div>
                        <div class="metric-stat-pill metric-stat-pill--warning">
                            <span class="metric-stat-pill__label">í”¼ë“œë°±</span>
                            <span class="metric-stat-pill__value">{context_feed:.1f}%</span>
                            <div class="metric-stat-pill__bar" style="width: {context_feed}%;"></div>
                        </div>
                    </div>
                </div>
                <div>
                    <div class="subsection-header">
                        <span class="subsection-header__icon">ğŸ§ </span>
                        <h3 class="subsection-header__title">ì¸ì§€ ìˆ˜ì¤€ ë¶„í¬</h3>
                    </div>
                    {level_distribution_chart}
                    <div class="metric-stats-grid mt-3">
                        <div class="metric-stat-pill metric-stat-pill--info">
                            <span class="metric-stat-pill__label">L1 (ê¸°ì–µ/ì´í•´)</span>
                            <span class="metric-stat-pill__value">{level_l1:.1f}%</span>
                            <div class="metric-stat-pill__bar" style="width: {level_l1}%;"></div>
                        </div>
                        <div class="metric-stat-pill metric-stat-pill--success">
                            <span class="metric-stat-pill__label">L2 (ì ìš©/ë¶„ì„)</span>
                            <span class="metric-stat-pill__value">{level_l2:.1f}%</span>
                            <div class="metric-stat-pill__bar" style="width: {level_l2}%;"></div>
                        </div>
                        <div class="metric-stat-pill metric-stat-pill--warning">
                            <span class="metric-stat-pill__label">L3 (í‰ê°€/ì°½ì¡°)</span>
                            <span class="metric-stat-pill__value">{level_l3:.1f}%</span>
                            <div class="metric-stat-pill__bar" style="width: {level_l3}%;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Pattern Matching -->
        <section class="section">
            <div class="section-header">
                <h2 class="section-title">êµìˆ˜ íŒ¨í„´ ë¶„ì„</h2>
                <p class="section-subtitle">ì´ìƒì  êµìˆ˜ íŒ¨í„´ê³¼ì˜ ìœ ì‚¬ë„ ë¹„êµ</p>
            </div>
            <div class="grid grid-cols-2 gap-6">
                <div>
                    <div class="subsection-header">
                        <span class="subsection-header__icon">ğŸ”</span>
                        <h3 class="subsection-header__title">íŒ¨í„´ ìœ ì‚¬ë„ ë¶„ì„</h3>
                    </div>
                    {pattern_similarity_chart}
                </div>
                <div>
                    <div class="card p-6">
                        <h3 class="text-xl font-bold text-primary-700 mb-2">
                            ê°€ì¥ ìœ ì‚¬í•œ íŒ¨í„´: {best_pattern_name}
                        </h3>
                        <p class="text-gray-700 mb-3">
                            {best_pattern_description}
                        </p>
                        <div class="flex items-center gap-2">
                            <div class="status-bar" style="width: 100%; height: 12px; border-radius: 6px;">
                                <div class="status-bar__fill" style="width: {best_pattern_similarity:.0f}%; background: var(--primary-500);"></div>
                            </div>
                            <span class="text-2xl font-mono font-bold text-primary-700">{best_pattern_similarity:.0f}%</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>

            </div>
            <!-- End Left Column -->

            <!-- Right Column: Profile, Strengths, Improvements, Recommendations -->
            <div class="two-column-layout__right">

        <!-- Strengths & Improvements (Now in Sidebar) -->
        <section class="section">
            <div class="section-header">
                <h2 class="section-title">ê°•ì  ë° ê°œì„  ì˜ì—­</h2>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <h3 class="text-xl font-semibold text-success mb-3">ê°•ì </h3>
                    {strengths_html}
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-warning mb-3">ê°œì„  ì˜ì—­</h3>
                    {improvements_html}
                </div>
            </div>
        </section>

        <!-- Coaching Recommendations -->
        <section class="section">
            <div class="section-header">
                <h2 class="section-title">ìš°ì„ ìˆœìœ„ ì½”ì¹­ ì¶”ì²œ</h2>
            </div>
            {recommendations_html}
        </section>

            </div>
            <!-- End Right Column -->

        </div>
        <!-- End Two-Column Layout -->

        <!-- Overall Assessment -->
        <section class="section">
            <div class="section-header">
                <h2 class="section-title">ì¢…í•© í‰ê°€</h2>
            </div>
            <div class="summary-card">
                <div class="summary-card__icon-wrapper">
                    <div class="summary-card__icon">ğŸ“‹</div>
                </div>
                <div class="summary-card__content">
                    <p class="summary-card__text">
                        {coaching_feedback.get('overall_assessment', 'ë¶„ì„ ì¤‘...')}
                    </p>
                </div>
            </div>
        </section>

        <!-- Footer -->
        <footer class="report-footer">
            <div class="report-footer__card">
                <div class="report-footer__icon">ğŸ“</div>
                <p class="report-footer__text">
                    ì´ ë³´ê³ ì„œëŠ” TVAS (Teacher Voice Analysis System)ì— ì˜í•´ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.
                </p>
                <p class="report-footer__contact">
                    ì§ˆë¬¸ì´ë‚˜ í”¼ë“œë°±: <a href="mailto:support@tvas.ai" class="report-footer__link">support@tvas.ai</a>
                </p>
                <div class="report-footer__timestamp">
                    ìƒì„± ì‹œê°: {timestamp} | ë¶„ì„ ID: {analysis_id}
                </div>
            </div>
        </footer>
    </div>
</body>
</html>
        '''

        return html


# Test/Demo function
if __name__ == "__main__":
    generator = DiagnosticReportGenerator()

    # Mock data for testing
    mock_data = {
        "analysis_id": "test_001",
        "framework": "cbil_comprehensive",
        "coaching_feedback": {
            "overall_assessment": "ì´ ìˆ˜ì—…ì€ ì „ë°˜ì ìœ¼ë¡œ ê· í˜•ì¡íŒ êµìˆ˜ ì „ëµì„ ë³´ì—¬ì¤ë‹ˆë‹¤. ë„ì…, ì „ê°œ, ì •ë¦¬ ë‹¨ê³„ê°€ ì ì ˆíˆ ë°°ë¶„ë˜ì—ˆìœ¼ë©°, í•™ìƒ ì°¸ì—¬ë¥¼ ìœ ë„í•˜ëŠ” ì§ˆë¬¸ì´ íš¨ê³¼ì ìœ¼ë¡œ ì‚¬ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.",
            "strengths": [
                "ë†’ì€ ì¸ì§€ ìˆ˜ì¤€ì˜ ì§ˆë¬¸ì„ í†µí•´ í•™ìƒë“¤ì˜ ê³ ì°¨ì›ì  ì‚¬ê³ ë¥¼ ì´‰ì§„í•¨",
                "ìˆ˜ì—… ë‹¨ê³„ ê°„ ì „í™˜ì´ ìì—°ìŠ¤ëŸ½ê³  ë…¼ë¦¬ì ì„",
                "ë‹¤ì–‘í•œ êµìˆ˜ ë§¥ë½(ì„¤ëª…, ì§ˆë¬¸, í”¼ë“œë°±)ì„ ì ì ˆíˆ í˜¼í•© ì‚¬ìš©"
            ],
            "areas_for_improvement": [
                "í•™ìƒ ë°œí™”ì— ëŒ€í•œ í”¼ë“œë°± ë¹ˆë„ê°€ ë‚®ìŒ",
                "ì •ë¦¬ ë‹¨ê³„ì—ì„œ í•™ìŠµ ë‚´ìš© ì •ë¦¬ ì‹œê°„ì´ ë¶€ì¡±í•¨",
                "ê°œë³„ í•™ìƒì— ëŒ€í•œ ë§ì¶¤í˜• ì§ˆë¬¸ì´ ì œí•œì ì„"
            ],
            "priority_actions": [
                "í•™ìƒ ì‘ë‹µ í›„ ì¦‰ê°ì ì´ê³  êµ¬ì²´ì ì¸ í”¼ë“œë°± ì œê³µí•˜ê¸°",
                "ì •ë¦¬ ë‹¨ê³„ë¥¼ ìµœì†Œ 5ë¶„ ì´ìƒ í™•ë³´í•˜ì—¬ í•™ìŠµ ë‚´ìš© ì •ë¦¬í•˜ê¸°",
                "ë‹¤ì–‘í•œ ìˆ˜ì¤€ì˜ í•™ìƒì„ ê³ ë ¤í•œ ì°¨ë³„í™”ëœ ì§ˆë¬¸ ì „ëµ ìˆ˜ë¦½í•˜ê¸°",
                "í•™ìƒ ê°„ ìƒí˜¸ì‘ìš©ì„ ì´‰ì§„í•˜ëŠ” ì§ˆë¬¸ ê¸°ë²• ì‚¬ìš©í•˜ê¸°",
                "ìˆ˜ì—… ì¤‘ê°„ì— í˜•ì„±í‰ê°€ë¥¼ í†µí•´ ì´í•´ë„ ì ê²€í•˜ê¸°"
            ]
        },
        "quantitative_metrics": {},
        "pattern_matching": {
            "best_match": {
                "pattern_name": "ê· í˜•ì¡íŒ ì´‰ì§„ì"
            }
        },
        "matrix_analysis": {}
    }

    html = generator.generate_html_report(mock_data)

    # Save to file for testing
    with open("test_diagnostic_report.html", "w", encoding="utf-8") as f:
        f.write(html)

    print("âœ“ diagnostic report generated: test_diagnostic_report.html")
    print(f"âœ“ Report length: {len(html)} characters")
